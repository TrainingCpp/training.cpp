#include <iostream>
#include <fstream>
#include <string>
#include <vector>

using namespace std;

class CPU {
protected:
    int AX = 0, BX = 0, CX = 0, DX = 0;
    vector<int> memory;  // Use vector instead of array
    bool halted = false;

    // Constructor initializes vector with 16 zeros
    CPU() {
        memory = vector<int>(16, 0);
    }

    // Parses an instruction line into its parts
    void parse(const string& line, string& instr, string& op1, string& op2) {
        instr = "";
        op1 = "";
        op2 = "";

        string code = line;

        // Remove comments
        size_t commentPos = code.find(';');
        if (commentPos != string::npos)
            code = code.substr(0, commentPos);

        // Replace commas with spaces
        while (code.find(',') != string::npos)
            code[code.find(',')] = ' ';

        // Normalize spacing
        string cleaned = "";
        bool spaceFlag = false;
        for (char c : code) {
            if (c == ' ' || c == '\t') {
                if (!spaceFlag && !cleaned.empty()) {
                    cleaned += ' ';
                    spaceFlag = true;
                }
            } else {
                cleaned += c;
                spaceFlag = false;
            }
        }

        if (!cleaned.empty() && cleaned.front() == ' ') cleaned.erase(0, 1);
        if (!cleaned.empty() && cleaned.back() == ' ') cleaned.pop_back();

        // Split into tokens
        size_t p1 = cleaned.find(' ');
        if (p1 == string::npos) {
            instr = cleaned;
            return;
        }

        instr = cleaned.substr(0, p1);
        size_t p2 = cleaned.find(' ', p1 + 1);
        if (p2 == string::npos) {
            op1 = cleaned.substr(p1 + 1);
            return;
        }

        op1 = cleaned.substr(p1 + 1, p2 - p1 - 1);
        op2 = cleaned.substr(p2 + 1);
    }

    // Returns pointer to register/memory or stores immediate value in imm
    int* getOperand(const string& op, int& imm) {
        if (op.size() >= 3 && op[0] == '[' && op.back() == ']') {
            int idx = stoi(op.substr(1, op.size() - 2));
            if (idx >= 0 && idx < memory.size()) return &memory.at(idx);
            cout << "Invalid memory index\n";
            return nullptr;
        }

        if (op == "AX") return &AX;
        if (op == "BX") return &BX;
        if (op == "CX") return &CX;
        if (op == "DX") return &DX;

        imm = stoi(op);
        return nullptr;
    }

public:
    // Execute one instruction line
    void execute(const string& line) {
        if (halted) return;

        string instr, op1, op2;
        parse(line, instr, op1, op2);
        if (instr.empty()) return;

        int imm = 0;
        int* dest = getOperand(op1, imm);
        int* src = getOperand(op2, imm);

        if (instr == "MOV") {
            if (dest) {
                if (src) *dest = *src;
                else *dest = imm;
            } else cout << "Invalid MOV destination\n";
        }
        else if (instr == "ADD") {
            if (dest) {
                if (src) *dest += *src;
                else *dest += imm;
            } else cout << "Invalid ADD destination\n";
        }
        else if (instr == "SUB") {
            if (dest) {
                if (src) *dest -= *src;
                else *dest -= imm;
            } else cout << "Invalid SUB destination\n";
        }
        else if (instr == "MUL") {
            if (dest) {
                if (src) *dest *= *src;
                else *dest *= imm;
            } else cout << "Invalid MUL destination\n";
        }
        else if (instr == "DIV") {
            if (dest) {
                int divisor = src ? *src : imm;
                if (divisor == 0) cout << "Division by zero!\n";
                else *dest /= divisor;
            } else cout << "Invalid DIV destination\n";
        }
        else if (instr == "HLT") {
            halted = true;
        }
        else {
            cout << "Unknown instruction: " << instr << "\n";
        }
    }

    // Show the register and memory state
    void dump() {
        cout << "\n=== CPU STATE ===\n";
        cout << "AX: " << AX << "\n";
        cout << "BX: " << BX << "\n";
        cout << "CX: " << CX << "\n";
        cout << "DX: " << DX << "\n";
        cout << "\nMemory:\n";
        for (int i = 0; i < memory.size(); ++i) {
            cout << "[" << i << "] = " << memory[i] << "\n";
        }
    }

    bool isHalted() { return halted; }

    // Static method to create an instance (since constructor is protected)
    static CPU create() {
        return CPU();
    }
};

int main() {
    CPU cpu = CPU::create(); // Create CPU with vector memory

    ifstream file("input.txt");
    if (!file.is_open()) {
        cout << "Could not open input.txt\n";
        return 1;
    }

    string line;
    while (getline(file, line)) {
        cpu.execute(line);
        if (cpu.isHalted()) break;
    }

    cpu.dump();
    return 0;
}
