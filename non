#include <iostream>
#include <fstream>
#include <vector>
#include <string>

using namespace std;

class CPU {
protected:
    int AX = 0, BX = 0, CX = 0, DX = 0;
    int memory[16] = {0};
    bool halted = false;

    // Parse line directly into instr, op1, op2 without token strings
    void parse(const string& line, string& instr, string& op1, string& op2) {
        instr.clear();
        op1.clear();
        op2.clear();

        vector<char> chars(line.begin(), line.end());
        int part = 0; // 0=instr, 1=op1, 2=op2
        string* current = &instr;

        for (size_t i = 0; i < chars.size(); ++i) {
            char c = chars[i];
            if (c == ';') break; // comment

            if (c == ' ' || c == ',' || c == '\t') {
                if (!current->empty()) {
                    if (part == 0) {
                        current = &op1;
                        part = 1;
                    } else if (part == 1) {
                        current = &op2;
                        part = 2;
                    }
                }
            } else {
                current->push_back(c);
            }
        }
    }

    int* getOperand(const string& op, int& imm) {
        if (op.size() >= 3 && op.front() == '[' && op.back() == ']') {
            int idx = stoi(op.substr(1, op.size() - 2));
            if (idx >= 0 && idx < 16) return &memory[idx];
            cout << "Invalid memory index\n";
            return nullptr;
        }
        if (op == "AX") return &AX;
        if (op == "BX") return &BX;
        if (op == "CX") return &CX;
        if (op == "DX") return &DX;

        imm = stoi(op);
        return nullptr;
    }

public:
    void execute(const string& line) {
        if (halted) return;

        string instr, op1, op2;
        parse(line, instr, op1, op2);
        if (instr.empty()) return;

        int imm = 0;
        int* dest = getOperand(op1, imm);
        int* src = getOperand(op2, imm);

        if (instr == "MOV") {
            if (dest) {
                if (src) *dest = *src;
                else *dest = imm;
            } else cout << "Invalid MOV destination\n";
        }
        else if (instr == "ADD") {
            if (dest) {
                if (src) *dest += *src;
                else *dest += imm;
            } else cout << "Invalid ADD destination\n";
        }
        else if (instr == "SUB") {
            if (dest) {
                if (src) *dest -= *src;
                else *dest -= imm;
            } else cout << "Invalid SUB destination\n";
        }
        else if (instr == "MUL") {
            if (dest) {
                if (src) *dest *= *src;
                else *dest *= imm;
            } else cout << "Invalid MUL destination\n";
        }
        else if (instr == "DIV") {
            if (dest) {
                int divisor = src ? *src : imm;
                if (divisor == 0) cout << "Division by zero!\n";
                else *dest /= divisor;
            } else cout << "Invalid DIV destination\n";
        }
        else if (instr == "HLT") {
            halted = true;
        }
        else {
            cout << "Unknown instruction: " << instr << "\n";
        }
    }

    void dump() {
        cout << "\n=== CPU STATE ===\n";
        cout << "AX: " << AX << "\n";
        cout << "BX: " << BX << "\n";
        cout << "CX: " << CX << "\n";
        cout << "DX: " << DX << "\n";
        cout << "\nMemory:\n";
        for (int i = 0; i < 16; ++i) {
            cout << "[" << i << "] = " << memory[i] << "\n";
        }
    }

    bool isHalted() { return halted; }
};

int main() {
    CPU cpu;
    ifstream file("input.txt");
    if (!file.is_open()) {
        cout << "Could not open input.txt\n";
        return 1;
    }

    string line;
    while (getline(file, line)) {
        cpu.execute(line);
        if (cpu.isHalted()) break;
    }

    cpu.dump();
    return 0;
}
