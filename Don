//network traffic analysis 

#include <iostream>
#include <queue>
#include <vector>
#include <string>
#include <thread>
#include <mutex>
#include <fstream>
#include <map>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

struct Packet {
    string source;
    string destination;
    int size; // Size in KB

    Packet(const string& src, const string& dest, int sz) : source(src), destination(dest), size(sz) {}
};

// Router class
class Router {
private:
    string routerId;
    queue<Packet> packetQueue;
    vector<Packet> processedPackets;
    mutex mtx;

public:
    Router(const string& id) : routerId(id) {}

    void addPacket(const Packet& packet) {
        lock_guard<mutex> lock(mtx);
        packetQueue.push(packet);
    }

    void processPackets() {
        lock_guard<mutex> lock(mtx);
        while (!packetQueue.empty()) {
            Packet packet = packetQueue.front();
            packetQueue.pop();
            processedPackets.push_back(packet);
        }
    }

    void logProcessedPackets() const {
        lock_guard<mutex> lock(mtx);
        ofstream logFile(routerId + "_traffic.log");

        for (const auto& packet : processedPackets) {
            logFile << "Source: " << packet.source << ", Destination: " << packet.destination
                    << ", Size: " << packet.size << "KB\n";
        }
        logFile.close();
    }

    int getTotalTraffic() const {
        lock_guard<mutex> lock(mtx);
        int totalTraffic = 0;
        for (const auto& packet : processedPackets) {
            totalTraffic += packet.size;
        }
        return totalTraffic;
    }

    string getRouterId() const { return routerId; }
};

// Traffic Analyzer
class TrafficAnalyzer {
private:
    map<string, int> routerTrafficData;

public:
    void analyzeTraffic(const vector<Router>& routers) {
        for (const auto& router : routers) {
            routerTrafficData[router.getRouterId()] = router.getTotalTraffic();
        }
    }

    void logTrafficAnalysis() const {
        ofstream analysisFile("traffic_analysis.log");

        analysisFile << "Router Traffic Analysis:\n";
        analysisFile << "-------------------------\n";

        for (const auto& [routerId, totalTraffic] : routerTrafficData) {
            analysisFile << "Router: " << routerId << ", Total Traffic: " << totalTraffic << "KB\n";
        }

        analysisFile.close();
    }
};

// Generate random packets for simulation
void generatePackets(Router& router) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> sizeDist(1, 500);
    uniform_int_distribution<> ipDist(1, 255);

    for (int i = 0; i < 10; ++i) {
        string srcIP = "192.168.1." + to_string(ipDist(gen));
        string destIP = "10.0.0." + to_string(ipDist(gen));
        int size = sizeDist(gen);
        router.addPacket(Packet(srcIP, destIP, size));
    }
}

// Process packets at a router
void processRouterPackets(Router& router) {
    router.processPackets();
    router.logProcessedPackets();
}

int main() {
    vector<Router> routers = {Router("Router1"), Router("Router2"), Router("Router3")};

    // Step 1: Generate packets
    vector<thread> packetThreads;
    for (auto& router : routers) {
        packetThreads.emplace_back(generatePackets, ref(router));
    }
    for (auto& thread : packetThreads) {
        thread.join();
    }

    // Step 2: Process packets
    vector<thread> processThreads;
    for (auto& router : routers) {
        processThreads.emplace_back(processRouterPackets, ref(router));
    }
    for (auto& thread : processThreads) {
        thread.join();
    }

    // Step 3: Analyze traffic
    TrafficAnalyzer analyzer;
    analyzer.analyzeTraffic(routers);
    analyzer.logTrafficAnalysis();

    cout << "Traffic analysis completed. Check logs for details.\n";
    return 0;
}

#include <iostream>
#include <queue>
#include <vector>
#include <string>
#include <thread>
#include <mutex>
#include <fstream>
#include <map>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

struct Packet {
    string source;
    string destination;
    int size; // Size in KB

    Packet(const string& src, const string& dest, int sz) : source(src), destination(dest), size(sz) {}
};

// Router class
class Router {
private:
    string routerId;
    queue<Packet> packetQueue;
    vector<Packet> processedPackets;
    mutex mtx;

public:
    Router(const string& id) : routerId(id) {}

    void addPacket(const Packet& packet) {
        lock_guard<mutex> lock(mtx);
        packetQueue.push(packet);
    }

    void processPackets() {
        lock_guard<mutex> lock(mtx);
        while (!packetQueue.empty()) {
            Packet packet = packetQueue.front();
            packetQueue.pop();
            processedPackets.push_back(packet);
        }
    }

    void logProcessedPackets() const {
        lock_guard<mutex> lock(mtx);
        ofstream logFile(routerId + "_traffic.log");

        for (const auto& packet : processedPackets) {
            logFile << "Source: " << packet.source << ", Destination: " << packet.destination
                    << ", Size: " << packet.size << "KB\n";
        }
        logFile.close();
    }

    int getTotalTraffic() const {
        lock_guard<mutex> lock(mtx);
        int totalTraffic = 0;
        for (const auto& packet : processedPackets) {
            totalTraffic += packet.size;
        }
        return totalTraffic;
    }

    string getRouterId() const { return routerId; }
};

// Traffic Analyzer
class TrafficAnalyzer {
private:
    map<string, int> routerTrafficData;

public:
    void analyzeTraffic(const vector<Router>& routers) {
        for (const auto& router : routers) {
            routerTrafficData[router.getRouterId()] = router.getTotalTraffic();
        }
    }

    void logTrafficAnalysis() const {
        ofstream analysisFile("traffic_analysis.log");

        analysisFile << "Router Traffic Analysis:\n";
        analysisFile << "-------------------------\n";

        for (const auto& [routerId, totalTraffic] : routerTrafficData) {
            analysisFile << "Router: " << routerId << ", Total Traffic: " << totalTraffic << "KB\n";
        }

        analysisFile.close();
    }
};

// Generate random packets for simulation
void generatePackets(Router& router) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> sizeDist(1, 500);
    uniform_int_distribution<> ipDist(1, 255);

    for (int i = 0; i < 10; ++i) {
        string srcIP = "192.168.1." + to_string(ipDist(gen));
        string destIP = "10.0.0." + to_string(ipDist(gen));
        int size = sizeDist(gen);
        router.addPacket(Packet(srcIP, destIP, size));
    }
}

// Process packets at a router
void processRouterPackets(Router& router) {
    router.processPackets();
    router.logProcessedPackets();
}

int main() {
    vector<Router> routers = {Router("Router1"), Router("Router2"), Router("Router3")};

    // Step 1: Generate packets
    vector<thread> packetThreads;
    for (auto& router : routers) {
        packetThreads.emplace_back(generatePackets, ref(router));
    }
    for (auto& thread : packetThreads) {
        thread.join();
    }

    // Step 2: Process packets
    vector<thread> processThreads;
    for (auto& router : routers) {
        processThreads.emplace_back(processRouterPackets, ref(router));
    }
    for (auto& thread : processThreads) {
        thread.join();
    }

    // Step 3: Analyze traffic
    TrafficAnalyzer analyzer;
    analyzer.analyzeTraffic(routers);
    analyzer.logTrafficAnalysis();

    cout << "Traffic analysis completed. Check logs for details.\n";
    return 0;
}



//cellular network optimization 


#include <iostream>
#include <map>
#include <set>
#include <vector>
#include <queue>
#include <thread>
#include <mutex>
#include <fstream>
#include <string>
#include <climits>

using namespace std;

struct Tower {
    string id;
    int load; // Current data load on the tower

    Tower(string id, int load) : id(id), load(load) {}
};

class Network {
private:
    map<string, set<string>> connections; // Graph: Tower ID -> Set of connected Tower IDs
    map<string, Tower> towers;            // Tower ID -> Tower
    mutex mtx;

public:
    void addTower(const string& id, int load) {
        lock_guard<mutex> lock(mtx);
        towers[id] = Tower(id, load);
    }

    void addConnection(const string& from, const string& to) {
        lock_guard<mutex> lock(mtx);
        connections[from].insert(to);
        connections[to].insert(from); // Assuming bidirectional connection
    }

    vector<string> findShortestPath(const string& start, const string& end) {
        lock_guard<mutex> lock(mtx);

        if (connections.find(start) == connections.end() || connections.find(end) == connections.end()) {
            return {};
        }

        map<string, string> previous; // To reconstruct the path
        map<string, int> distances;   // Shortest distance to each tower
        set<string> visited;
        priority_queue<pair<int, string>, vector<pair<int, string>>, greater<>> pq;

        for (const auto& tower : towers) {
            distances[tower.first] = INT_MAX;
        }
        distances[start] = 0;

        pq.push({0, start});

        while (!pq.empty()) {
            auto [currentDistance, currentTower] = pq.top();
            pq.pop();

            if (visited.find(currentTower) != visited.end()) {
                continue;
            }

            visited.insert(currentTower);

            for (const auto& neighbor : connections[currentTower]) {
                int newDistance = currentDistance + 1; // All edges have equal weight
                if (newDistance < distances[neighbor]) {
                    distances[neighbor] = newDistance;
                    previous[neighbor] = currentTower;
                    pq.push({newDistance, neighbor});
                }
            }
        }

        vector<string> path;
        for (string at = end; at != ""; at = previous[at]) {
            path.push_back(at);
        }
        reverse(path.begin(), path.end());

        return (path.size() > 1 && path.front() == start) ? path : vector<string>{};
    }

    void optimizeTraffic(const string& overloadedTower) {
        lock_guard<mutex> lock(mtx);

        if (towers[overloadedTower].load <= 100) {
            return; // Load is manageable
        }

        cout << "Optimizing traffic for tower: " << overloadedTower << "\n";

        for (const auto& neighbor : connections[overloadedTower]) {
            int transferLoad = (towers[overloadedTower].load - 100) / 2;
            towers[neighbor].load += transferLoad;
            towers[overloadedTower].load -= transferLoad;

            ofstream logFile("network_optimization.log", ios::app);
            logFile << "Transferred " << transferLoad << " load from " << overloadedTower
                    << " to " << neighbor << "\n";
            logFile.close();

            if (towers[overloadedTower].load <= 100) {
                break;
            }
        }
    }

    void simulateTraffic() {
        lock_guard<mutex> lock(mtx);

        for (auto& [id, tower] : towers) {
            tower.load += rand() % 50; // Simulating data load increase
        }
    }

    void logTowerStatus() {
        lock_guard<mutex> lock(mtx);

        ofstream logFile("tower_status.log");
        for (const auto& [id, tower] : towers) {
            logFile << "Tower ID: " << id << ", Load: " << tower.load << "\n";
        }
        logFile.close();
    }
};

// Simulate real-time traffic
void simulateTraffic(Network& network) {
    while (true) {
        network.simulateTraffic();
        this_thread::sleep_for(chrono::seconds(5));
    }
}

// Optimize network
void optimizeNetwork(Network& network) {
    while (true) {
        for (const auto& [id, tower] : network) {
            if (tower.load > 100) {
                network.optimizeTraffic(id);
            }
        }
        this_thread::sleep_for(chrono::seconds(10));
    }
}

int main() {
    Network network;

    // Adding towers
    network.addTower("T1", 50);
    network.addTower("T2", 30);
    network.addTower("T3", 70);
    network.addTower("T4", 40);

    // Adding connections
    network.addConnection("T1", "T2");
    network.addConnection("T2", "T3");
    network.addConnection("T3", "T4");

    // Start traffic simulation and optimization in separate threads
    thread trafficThread(simulateTraffic, ref(network));
    thread optimizationThread(optimizeNetwork, ref(network));

    trafficThread.join();
    optimizationThread.join();

    return 0;
}



//telecom billing system 

#include <iostream>
#include <map>
#include <queue>
#include <vector>
#include <string>
#include <thread>
#include <mutex>
#include <fstream>
#include <random>
#include <chrono>

using namespace std;

// Class to represent a telecom service
class Service {
private:
    string serviceName;
    double costPerUnit;

public:
    Service(const string& name, double cost) : serviceName(name), costPerUnit(cost) {}
    double getCostPerUnit() const { return costPerUnit; }
    string getServiceName() const { return serviceName; }
};

// Class to represent a user
class User {
private:
    string username;
    map<string, int> serviceUsage; // Service name and usage

public:
    User(const string& name) : username(name) {}

    void addServiceUsage(const string& serviceName, int units) {
        serviceUsage[serviceName] += units;
    }

    const map<string, int>& getServiceUsage() const { return serviceUsage; }
    string getUsername() const { return username; }
};

// Class to represent a billing system
class BillingSystem {
private:
    map<string, Service> services;
    map<string, User> users;
    mutex mtx;

public:
    void addService(const string& name, double cost) {
        lock_guard<mutex> lock(mtx);
        services[name] = Service(name, cost);
    }

    void addUser(const string& username) {
        lock_guard<mutex> lock(mtx);
        users[username] = User(username);
    }

    void generateUsageData() {
        lock_guard<mutex> lock(mtx);

        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> dist(1, 100);

        for (auto& [username, user] : users) {
            for (const auto& [serviceName, service] : services) {
                user.addServiceUsage(serviceName, dist(gen)); // Random usage
            }
        }
    }

    void generateBills() {
        lock_guard<mutex> lock(mtx);

        for (const auto& [username, user] : users) {
            double totalBill = 0;
            ofstream billFile(username + "_bill.txt");

            billFile << "Monthly Bill for User: " << username << "\n";
            billFile << "----------------------------------\n";

            for (const auto& [serviceName, usage] : user.getServiceUsage()) {
                double cost = services[serviceName].getCostPerUnit() * usage;
                totalBill += cost;
                billFile << "Service: " << serviceName << ", Usage: " << usage 
                         << ", Cost: $" << cost << "\n";
            }

            billFile << "----------------------------------\n";
            billFile << "Total Bill: $" << totalBill << "\n";
            billFile.close();
        }
    }
};

void simulateUserUsage(BillingSystem& system) {
    system.generateUsageData();
}

void simulateBilling(BillingSystem& system) {
    system.generateBills();
}

int main() {
    BillingSystem billingSystem;

    // Adding services
    billingSystem.addService("Voice Call", 0.1);  // $0.1 per minute
    billingSystem.addService("Data", 0.05);       // $0.05 per MB
    billingSystem.addService("SMS", 0.02);        // $0.02 per SMS

    // Adding users
    billingSystem.addUser("Alice");
    billingSystem.addUser("Bob");
    billingSystem.addUser("Charlie");

    // Simulate usage and billing
    thread usageThread(simulateUserUsage, ref(billingSystem));
    thread billingThread(simulateBilling, ref(billingSystem));

    usageThread.join();
    billingThread.join();

    cout << "Billing completed. Check individual user bill files for details.\n";

    return 0;
}



//spam detection system 

#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <fstream>
#include <thread>
#include <mutex>
#include <algorithm>

using namespace std;

// Base class Message
class Message {
protected:
    string content;
    bool isSpam;

public:
    Message(const string& msg) : content(msg), isSpam(false) {}
    virtual ~Message() = default;

    virtual string getMessageType() const = 0;

    const string& getContent() const { return content; }
    bool checkSpam() const { return isSpam; }
    void markSpam() { isSpam = true; }
};

// Derived class SMS
class SMS : public Message {
public:
    SMS(const string& msg) : Message(msg) {}
    string getMessageType() const override { return "SMS"; }
};

// Derived class MMS
class MMS : public Message {
public:
    MMS(const string& msg) : Message(msg) {}
    string getMessageType() const override { return "MMS"; }
};

// Thread-safe structure to handle message processing
class SpamDetector {
private:
    unordered_map<string, int> spamKeywords;
    vector<shared_ptr<Message>> messages;
    mutex mtx;

public:
    SpamDetector() {
        // Initialize spam keywords with scores
        spamKeywords = {
            {"win", 10}, {"prize", 8}, {"free", 7}, {"money", 9},
            {"urgent", 6}, {"call", 5}, {"offer", 4}, {"cash", 10}
        };
    }

    void addMessage(shared_ptr<Message> message) {
        lock_guard<mutex> lock(mtx);
        messages.push_back(message);
    }

    void processMessages() {
        vector<shared_ptr<Message>> localMessages;

        {
            lock_guard<mutex> lock(mtx);
            localMessages.swap(messages);
        }

        for (auto& message : localMessages) {
            int spamScore = 0;

            for (const auto& [keyword, score] : spamKeywords) {
                if (message->getContent().find(keyword) != string::npos) {
                    spamScore += score;
                }
            }

            if (spamScore > 15) {
                message->markSpam();
            }
        }
    }

    void logResults(const string& logFilename) {
        ofstream logfile(logFilename, ios::app);

        for (const auto& message : messages) {
            logfile << "Message Type: " << message->getMessageType() << "\n";
            logfile << "Content: " << message->getContent() << "\n";
            logfile << "Status: " << (message->checkSpam() ? "Spam" : "Not Spam") << "\n\n";
        }
    }
};

void processBatch(SpamDetector& detector) {
    detector.processMessages();
    detector.logResults("spam_detection.log");
}

int main() {
    SpamDetector detector;

    // Simulate incoming messages
    detector.addMessage(make_shared<SMS>("You won a free prize! Call now!"));
    detector.addMessage(make_shared<MMS>("This is a test message."));
    detector.addMessage(make_shared<SMS>("Urgent! You have cash waiting for you."));

    // Multithreaded processing
    thread t1(processBatch, ref(detector));
    thread t2(processBatch, ref(detector));

    t1.join();
    t2.join();

    cout << "Spam detection completed. Check spam_detection.log for details.\n";

    return 0;
}





//call routing system 
#include <iostream> #include <thread> #include <queue> #include <unordered_map> #include <mutex> #include <vector> #include <string> #include <fstream> #include <chrono> #include <condition_variable> #include <set>

using namespace std;

class Call { public: string callId; string source; string destination; int priority;

Call(string id, string src, string dest, int prio)
    : callId(id), source(src), destination(dest), priority(prio) {}

bool operator<(const Call& other) const {
    return priority < other.priority;  // Higher priority calls first
}

};

class CallRouter { private: priority_queue<Call> callQueue; unordered_map<string, string> activeCalls; mutex mtx; condition_variable cv; bool running;

public: CallRouter() : running(true) {}

void addCall(const Call& call) {
    lock_guard<mutex> lock(mtx);
    callQueue.push(call);
    cv.notify_one();
}

void processCalls() {
    while (running) {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, [&] { return !callQueue.empty() || !running; });

        if (!running) break;

        Call call = callQueue.top();
        callQueue.pop();
        lock.unlock();

        // Simulate call routing
        {
            lock_guard<mutex> lock(mtx);
            activeCalls[call.callId] = call.destination;
        }

        cout << "Routing call " << call.callId << " from " << call.source
             << " to " << call.destination << " with priority " << call.priority << endl;

        this_thread::sleep_for(chrono::seconds(2)); // Simulating processing time

        // Simulate call end
        {
            lock_guard<mutex> lock(mtx);
            activeCalls.erase(call.callId);
            cout << "Call " << call.callId << " has ended." << endl;
        }
    }
}

void stop() {
    running = false;
    cv.notify_all();
}

void logActiveCalls() {
    lock_guard<mutex> lock(mtx);
    ofstream logFile("active_calls.txt", ios::app);
    logFile << "Active Calls at " << chrono::system_clock::to_time_t(chrono::system_clock::now()) << ":\n";
    for (const auto& call : activeCalls) {
        logFile << "Call ID: " << call.first << " -> Destination: " << call.second << endl;
    }
    logFile.close();
}

};

int main() { CallRouter router;

thread routerThread(&CallRouter::processCalls, &router);

vector<thread> callerThreads;

// Simulating callers adding calls
for (int i = 1; i <= 5; ++i) {
    callerThreads.push_back(thread([&, i]() {
        string callId = "Call" + to_string(i);
        string source = "User" + to_string(i);
        string destination = "User" + to_string(i + 5);
        int priority = rand() % 10 + 1; // Priority between 1 and 10
        router.addCall(Call(callId, source, destination, priority));
    }));
    this_thread::sleep_for(chrono::seconds(1));
}

// Wait for all caller threads to finish
for (auto& t : callerThreads) {
    t.join();
}

// Log active calls periodically
thread loggerThread([&]() {
    for (int i = 0; i < 5; ++i) {
        router.logActiveCalls();
        this_thread::sleep_for(chrono::seconds(3));
    }
});

loggerThread.join();

// Stop the router and join the router thread
router.stop();
routerThread.join();

return 0;

}

