//call routing system 
#include <iostream> #include <thread> #include <queue> #include <unordered_map> #include <mutex> #include <vector> #include <string> #include <fstream> #include <chrono> #include <condition_variable> #include <set>

using namespace std;

class Call { public: string callId; string source; string destination; int priority;

Call(string id, string src, string dest, int prio)
    : callId(id), source(src), destination(dest), priority(prio) {}

bool operator<(const Call& other) const {
    return priority < other.priority;  // Higher priority calls first
}

};

class CallRouter { private: priority_queue<Call> callQueue; unordered_map<string, string> activeCalls; mutex mtx; condition_variable cv; bool running;

public: CallRouter() : running(true) {}

void addCall(const Call& call) {
    lock_guard<mutex> lock(mtx);
    callQueue.push(call);
    cv.notify_one();
}

void processCalls() {
    while (running) {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, [&] { return !callQueue.empty() || !running; });

        if (!running) break;

        Call call = callQueue.top();
        callQueue.pop();
        lock.unlock();

        // Simulate call routing
        {
            lock_guard<mutex> lock(mtx);
            activeCalls[call.callId] = call.destination;
        }

        cout << "Routing call " << call.callId << " from " << call.source
             << " to " << call.destination << " with priority " << call.priority << endl;

        this_thread::sleep_for(chrono::seconds(2)); // Simulating processing time

        // Simulate call end
        {
            lock_guard<mutex> lock(mtx);
            activeCalls.erase(call.callId);
            cout << "Call " << call.callId << " has ended." << endl;
        }
    }
}

void stop() {
    running = false;
    cv.notify_all();
}

void logActiveCalls() {
    lock_guard<mutex> lock(mtx);
    ofstream logFile("active_calls.txt", ios::app);
    logFile << "Active Calls at " << chrono::system_clock::to_time_t(chrono::system_clock::now()) << ":\n";
    for (const auto& call : activeCalls) {
        logFile << "Call ID: " << call.first << " -> Destination: " << call.second << endl;
    }
    logFile.close();
}

};

int main() { CallRouter router;

thread routerThread(&CallRouter::processCalls, &router);

vector<thread> callerThreads;

// Simulating callers adding calls
for (int i = 1; i <= 5; ++i) {
    callerThreads.push_back(thread([&, i]() {
        string callId = "Call" + to_string(i);
        string source = "User" + to_string(i);
        string destination = "User" + to_string(i + 5);
        int priority = rand() % 10 + 1; // Priority between 1 and 10
        router.addCall(Call(callId, source, destination, priority));
    }));
    this_thread::sleep_for(chrono::seconds(1));
}

// Wait for all caller threads to finish
for (auto& t : callerThreads) {
    t.join();
}

// Log active calls periodically
thread loggerThread([&]() {
    for (int i = 0; i < 5; ++i) {
        router.logActiveCalls();
        this_thread::sleep_for(chrono::seconds(3));
    }
});

loggerThread.join();

// Stop the router and join the router thread
router.stop();
routerThread.join();

return 0;

}

