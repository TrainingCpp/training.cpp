#include <iostream>
#include <vector>
#include <string>

using namespace std;

// Class to represent operator data
class Operator {
private:
    string brandName;
    string mccMncCode;

    int incomingCallDuration;
    int outgoingCallDuration;
    int incomingSMS;
    int outgoingSMS;

    double mbDownloaded;
    double mbUploaded;

public:
    Operator(const string& name, const string& code,
             int inCall, int outCall, int inSMS, int outSMS,
             double mbDown, double mbUp)
        : brandName(name), mccMncCode(code),
          incomingCallDuration(inCall), outgoingCallDuration(outCall),
          incomingSMS(inSMS), outgoingSMS(outSMS),
          mbDownloaded(mbDown), mbUploaded(mbUp) {}

    void display() const {
        cout << "Operator Brand: " << brandName << " (" << mccMncCode << ")\n";
        cout << "\tIncoming voice call durations: " << incomingCallDuration << "\n";
        cout << "\tOutgoing voice call durations: " << outgoingCallDuration << "\n";
        cout << "\tIncoming SMS messages: " << incomingSMS << "\n";
        cout << "\tOutgoing SMS messages: " << outgoingSMS << "\n";
        cout << "\tMB downloaded: " << mbDownloaded << " | MB uploaded: " << mbUploaded << "\n\n";
    }
};

// Class to represent customer data
class Customer {
private:
    int customerID;
    string operatorName;

    int inCallWithinOperator;
    int outCallWithinOperator;
    int inSMSWithinOperator;
    int outSMSWithinOperator;

    int inCallOutsideOperator;
    int outCallOutsideOperator;
    int inSMSOutsideOperator;
    int outSMSOutsideOperator;

    double mbDownloaded;
    double mbUploaded;

public:
    Customer(int id, const string& opName,
             int inCallWithin, int outCallWithin, int inSMSWithin, int outSMSWithin,
             int inCallOutside, int outCallOutside, int inSMSOutside, int outSMSOutside,
             double mbDown, double mbUp)
        : customerID(id), operatorName(opName),
          inCallWithinOperator(inCallWithin), outCallWithinOperator(outCallWithin),
          inSMSWithinOperator(inSMSWithin), outSMSWithinOperator(outSMSWithin),
          inCallOutsideOperator(inCallOutside), outCallOutsideOperator(outCallOutside),
          inSMSOutsideOperator(inSMSOutside), outSMSOutsideOperator(outSMSOutside),
          mbDownloaded(mbDown), mbUploaded(mbUp) {}

    void display() const {
        cout << "Customer ID: " << customerID << " (" << operatorName << ")\n";
        cout << "\t* Services within the mobile operator *\n";
        cout << "\tIncoming voice call durations: " << inCallWithinOperator << "\n";
        cout << "\tOutgoing voice call durations: " << outCallWithinOperator << "\n";
        cout << "\tIncoming SMS messages: " << inSMSWithinOperator << "\n";
        cout << "\tOutgoing SMS messages: " << outSMSWithinOperator << "\n";
        cout << "\t* Services outside the mobile operator *\n";
        cout << "\tIncoming voice call durations: " << inCallOutsideOperator << "\n";
        cout << "\tOutgoing voice call durations: " << outCallOutsideOperator << "\n";
        cout << "\tIncoming SMS messages: " << inSMSOutsideOperator << "\n";
        cout << "\tOutgoing SMS messages: " << outSMSOutsideOperator << "\n";
        cout << "\t* Internet use *\n";
        cout << "\tMB downloaded: " << mbDownloaded << " | MB uploaded: " << mbUploaded << "\n\n";
    }
};

int main() {
    vector<Operator> operators = {
        {"Cellcom", "42500", 844736, 874157, 4000, 3990, 408486, 416108},
        {"012", "42504", 862576, 855646, 3905, 3998, 435195, 422003},
        {"Airtel", "42503", 853500, 882069, 3990, 3986, 429235, 432627},
        {"Partner", "42501", 883043, 851048, 3940, 4017, 439487, 428699},
        {"JIO", "42502", 876475, 879242, 3907, 4088, 445752, 418127}
    };

    vector<Customer> customers = {
        {1522840, "JIO", 0, 0, 0, 0, 0, 312, 0, 0, 0, 0},
        {1169862, "012", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {1964107, "Airtel", 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
        {1280634, "JIO", 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
        {1952023, "Partner", 0, 0, 0, 0, 347, 0, 0, 0, 0, 0}
    };

    // Display operator data
    cout << "# Operator Data Base:\n";
    for (const auto& op : operators) {
        op.display();
    }

    // Display customer data
    cout << "# Customers Data Base:\n";
    for (const auto& cust : customers) {
        cust.display();
    }

    return 0;
}



//telecom customer feedback analyer
#include <iostream>
#include <vector>
#include <unordered_map>
#include <thread>
#include <mutex>
#include <fstream>
#include <string>
#include <algorithm>

using namespace std;

// Base Feedback class
class Feedback {
protected:
    string message;

public:
    Feedback(const string& msg) : message(msg) {}
    virtual void analyze(unordered_map<string, int>& keywordCounts) const = 0;
    virtual ~Feedback() = default;
};

// Derived class for Call Quality Feedback
class CallQualityFeedback : public Feedback {
public:
    CallQualityFeedback(const string& msg) : Feedback(msg) {}

    void analyze(unordered_map<string, int>& keywordCounts) const override {
        vector<string> keywords = {"call drop", "noise", "clarity"};
        for (const auto& keyword : keywords) {
            if (message.find(keyword) != string::npos) {
                keywordCounts[keyword]++;
            }
        }
    }
};

// Derived class for Billing Feedback
class BillingFeedback : public Feedback {
public:
    BillingFeedback(const string& msg) : Feedback(msg) {}

    void analyze(unordered_map<string, int>& keywordCounts) const override {
        vector<string> keywords = {"overcharged", "bill", "refund"};
        for (const auto& keyword : keywords) {
            if (message.find(keyword) != string::npos) {
                keywordCounts[keyword]++;
            }
        }
    }
};

// Derived class for General Feedback
class GeneralFeedback : public Feedback {
public:
    GeneralFeedback(const string& msg) : Feedback(msg) {}

    void analyze(unordered_map<string, int>& keywordCounts) const override {
        vector<string> keywords = {"service", "support", "experience"};
        for (const auto& keyword : keywords) {
            if (message.find(keyword) != string::npos) {
                keywordCounts[keyword]++;
            }
        }
    }
};

// Telecom Customer Feedback Analyzer
class FeedbackAnalyzer {
private:
    vector<Feedback*> feedbacks;
    mutex mtx;

public:
    void addFeedback(Feedback* feedback) {
        lock_guard<mutex> lock(mtx);
        feedbacks.push_back(feedback);
    }

    void analyzeFeedback(const string& region) {
        unordered_map<string, int> keywordCounts;

        {
            lock_guard<mutex> lock(mtx);
            for (const auto& feedback : feedbacks) {
                feedback->analyze(keywordCounts);
            }
        }

        ofstream outFile(region + "_feedback_summary.txt");
        outFile << "Feedback Summary for Region: " << region << "\n";
        for (const auto& entry : keywordCounts) {
            outFile << entry.first << ": " << entry.second << "\n";
        }
        outFile.close();
    }

    ~FeedbackAnalyzer() {
        for (auto feedback : feedbacks) {
            delete feedback;
        }
    }
};

// Simulate feedback processing for a specific region
void simulateRegionFeedback(FeedbackAnalyzer& analyzer, const string& region) {
    analyzer.analyzeFeedback(region);
}

int main() {
    FeedbackAnalyzer analyzer;

    // Add feedback for analysis
    analyzer.addFeedback(new CallQualityFeedback("The call had a lot of noise and clarity issues."));
    analyzer.addFeedback(new BillingFeedback("I was overcharged in my last bill."));
    analyzer.addFeedback(new GeneralFeedback("The customer service experience was excellent."));
    analyzer.addFeedback(new CallQualityFeedback("The call dropped multiple times during my conversation."));
    analyzer.addFeedback(new BillingFeedback("I need a refund for the extra charge."));
    analyzer.addFeedback(new GeneralFeedback("Overall service support has been great."));

    // Simulate feedback analysis for different regions
    vector<thread> threads;
    threads.emplace_back(simulateRegionFeedback, ref(analyzer), "North");
    threads.emplace_back(simulateRegionFeedback, ref(analyzer), "South");
    threads.emplace_back(simulateRegionFeedback, ref(analyzer), "East");
    threads.emplace_back(simulateRegionFeedback, ref(analyzer), "West");

    for (auto& thread : threads) {
        thread.join();
    }

    cout << "Feedback analysis completed. Check region-specific feedback summary files.\n";

    return 0;
}



//realtime sms broadcast system 


#include <iostream>
#include <unordered_map>
#include <queue>
#include <thread>
#include <mutex>
#include <vector>
#include <string>
#include <fstream>
#include <chrono>

using namespace std;

// Base Message class
class Message {
protected:
    string content;

public:
    Message(const string& msgContent) : content(msgContent) {}
    virtual void display() const = 0; // Pure virtual function
    virtual ~Message() = default;
};

// Derived BroadcastMessage class
class BroadcastMessage : public Message {
private:
    string region;

public:
    BroadcastMessage(const string& msgContent, const string& msgRegion)
        : Message(msgContent), region(msgRegion) {}

    void display() const override {
        cout << "Region: " << region << ", Message: " << content << endl;
    }

    string getRegion() const {
        return region;
    }
};

// SMS Broadcasting System
class SMSBroadcastingSystem {
private:
    unordered_map<string, queue<BroadcastMessage>> regionQueues;
    mutex mtx;

public:
    void addSubscriberRegion(const string& region) {
        lock_guard<mutex> lock(mtx);
        if (regionQueues.find(region) == regionQueues.end()) {
            regionQueues[region] = queue<BroadcastMessage>();
        }
    }

    void addBroadcastMessage(const BroadcastMessage& message) {
        lock_guard<mutex> lock(mtx);
        const string& region = message.getRegion();
        if (regionQueues.find(region) != regionQueues.end()) {
            regionQueues[region].push(message);
        }
    }

    void broadcastMessages(const string& region) {
        lock_guard<mutex> lock(mtx);
        if (regionQueues.find(region) == regionQueues.end()) return;

        ofstream logFile(region + "_broadcast.log", ios::app);
        while (!regionQueues[region].empty()) {
            BroadcastMessage message = regionQueues[region].front();
            regionQueues[region].pop();
            message.display();
            logFile << "Region: " << message.getRegion() << ", Message: " << message.content << endl;
        }
        logFile.close();
    }
};

// Simulate real-time broadcasting for a specific region
void simulateRegionBroadcast(SMSBroadcastingSystem& system, const string& region) {
    this_thread::sleep_for(chrono::seconds(1)); // Simulate processing delay
    system.broadcastMessages(region);
}

int main() {
    SMSBroadcastingSystem system;

    // Add regions
    system.addSubscriberRegion("North");
    system.addSubscriberRegion("South");
    system.addSubscriberRegion("East");
    system.addSubscriberRegion("West");

    // Add messages
    system.addBroadcastMessage(BroadcastMessage("Emergency Alert!", "North"));
    system.addBroadcastMessage(BroadcastMessage("Maintenance Notification", "South"));
    system.addBroadcastMessage(BroadcastMessage("Festival Greetings", "East"));
    system.addBroadcastMessage(BroadcastMessage("Weather Warning", "West"));
    system.addBroadcastMessage(BroadcastMessage("Traffic Update", "North"));
    system.addBroadcastMessage(BroadcastMessage("Service Downtime", "South"));

    // Simulate real-time broadcasting
    vector<thread> threads;
    threads.emplace_back(simulateRegionBroadcast, ref(system), "North");
    threads.emplace_back(simulateRegionBroadcast, ref(system), "South");
    threads.emplace_back(simulateRegionBroadcast, ref(system), "East");
    threads.emplace_back(simulateRegionBroadcast, ref(system), "West");

    for (auto& thread : threads) {
        thread.join();
    }

    cout << "Broadcasting completed. Check region-specific log files for details.\n";

    return 0;
}



//telecom fruad detection system 

#include <iostream>
#include <map>
#include <set>
#include <vector>
#include <thread>
#include <mutex>
#include <fstream>
#include <string>
#include <random>
#include <chrono>

using namespace std;

// Base class for fraud detection algorithms
class FraudDetection {
public:
    virtual void detectFraud(const vector<string>& callLogs) = 0;
    virtual ~FraudDetection() = default;
};

// Derived class for Sim Card Cloning Detection
class SimCloningDetection : public FraudDetection {
public:
    void detectFraud(const vector<string>& callLogs) override {
        set<string> uniqueNumbers;
        cout << "Detecting SIM cloning...\n";

        for (const auto& log : callLogs) {
            string number = log.substr(0, log.find(',')); // Extract source number
            if (uniqueNumbers.count(number)) {
                ofstream logFile("fraud_detection.log", ios::app);
                logFile << "Fraud detected: SIM cloning suspected for number " << number << "\n";
                logFile.close();
            }
            uniqueNumbers.insert(number);
        }
    }
};

// Derived class for Unusual Activity Detection
class UnusualActivityDetection : public FraudDetection {
public:
    void detectFraud(const vector<string>& callLogs) override {
        map<string, int> callDuration;

        cout << "Detecting unusual activities...\n";

        for (const auto& log : callLogs) {
            size_t pos1 = log.find(',');
            size_t pos2 = log.find(',', pos1 + 1);
            string number = log.substr(0, pos1);
            int duration = stoi(log.substr(pos2 + 1)); // Extract duration

            callDuration[number] += duration;

            if (callDuration[number] > 3000) { // Unusual duration threshold
                ofstream logFile("fraud_detection.log", ios::app);
                logFile << "Fraud detected: Unusual activity for number " << number << " with total duration " << callDuration[number] << "\n";
                logFile.close();
            }
        }
    }
};

// Telecom Fraud Detection System
class TelecomFraudDetectionSystem {
private:
    vector<string> callLogs;
    set<string> blacklistedNumbers;
    vector<unique_ptr<FraudDetection>> detectionAlgorithms;
    mutex mtx;

public:
    void addCallLog(const string& log) {
        lock_guard<mutex> lock(mtx);
        callLogs.push_back(log);
    }

    void addBlacklistedNumber(const string& number) {
        lock_guard<mutex> lock(mtx);
        blacklistedNumbers.insert(number);
    }

    void detectFraud() {
        lock_guard<mutex> lock(mtx);
        for (const auto& algorithm : detectionAlgorithms) {
            algorithm->detectFraud(callLogs);
        }
    }

    void addDetectionAlgorithm(unique_ptr<FraudDetection> algorithm) {
        detectionAlgorithms.push_back(move(algorithm));
    }

    void logBlacklistedFraud() {
        lock_guard<mutex> lock(mtx);
        ofstream logFile("fraud_detection.log", ios::app);

        for (const auto& log : callLogs) {
            string number = log.substr(0, log.find(',')); // Extract source number
            if (blacklistedNumbers.count(number)) {
                logFile << "Fraud detected: Call from blacklisted number " << number << "\n";
            }
        }

        logFile.close();
    }
};

// Simulate call log generation
void generateCallLogs(TelecomFraudDetectionSystem& system) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> numberDist(1000000000, 9999999999); // Random 10-digit numbers
    uniform_int_distribution<> durationDist(1, 500);              // Random durations

    for (int i = 0; i < 100; ++i) {
        string log = to_string(numberDist(gen)) + ",9876543210," + to_string(durationDist(gen));
        system.addCallLog(log);
    }
}

int main() {
    TelecomFraudDetectionSystem system;

    // Add detection algorithms
    system.addDetectionAlgorithm(make_unique<SimCloningDetection>());
    system.addDetectionAlgorithm(make_unique<UnusualActivityDetection>());

    // Add blacklisted numbers
    system.addBlacklistedNumber("1234567890");
    system.addBlacklistedNumber("9876543210");

    // Generate call logs
    thread logGenerator(generateCallLogs, ref(system));
    logGenerator.join();

    // Detect fraud
    system.detectFraud();
    system.logBlacklistedFraud();

    cout << "Fraud detection completed. Check fraud_detection.log for details.\n";

    return 0;
}


//network traffic analysis 

#include <iostream>
#include <queue>
#include <vector>
#include <string>
#include <thread>
#include <mutex>
#include <fstream>
#include <map>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

struct Packet {
    string source;
    string destination;
    int size; // Size in KB

    Packet(const string& src, const string& dest, int sz) : source(src), destination(dest), size(sz) {}
};

// Router class
class Router {
private:
    string routerId;
    queue<Packet> packetQueue;
    vector<Packet> processedPackets;
    mutex mtx;

public:
    Router(const string& id) : routerId(id) {}

    void addPacket(const Packet& packet) {
        lock_guard<mutex> lock(mtx);
        packetQueue.push(packet);
    }

    void processPackets() {
        lock_guard<mutex> lock(mtx);
        while (!packetQueue.empty()) {
            Packet packet = packetQueue.front();
            packetQueue.pop();
            processedPackets.push_back(packet);
        }
    }

    void logProcessedPackets() const {
        lock_guard<mutex> lock(mtx);
        ofstream logFile(routerId + "_traffic.log");

        for (const auto& packet : processedPackets) {
            logFile << "Source: " << packet.source << ", Destination: " << packet.destination
                    << ", Size: " << packet.size << "KB\n";
        }
        logFile.close();
    }

    int getTotalTraffic() const {
        lock_guard<mutex> lock(mtx);
        int totalTraffic = 0;
        for (const auto& packet : processedPackets) {
            totalTraffic += packet.size;
        }
        return totalTraffic;
    }

    string getRouterId() const { return routerId; }
};

// Traffic Analyzer
class TrafficAnalyzer {
private:
    map<string, int> routerTrafficData;

public:
    void analyzeTraffic(const vector<Router>& routers) {
        for (const auto& router : routers) {
            routerTrafficData[router.getRouterId()] = router.getTotalTraffic();
        }
    }

    void logTrafficAnalysis() const {
        ofstream analysisFile("traffic_analysis.log");

        analysisFile << "Router Traffic Analysis:\n";
        analysisFile << "-------------------------\n";

        for (const auto& [routerId, totalTraffic] : routerTrafficData) {
            analysisFile << "Router: " << routerId << ", Total Traffic: " << totalTraffic << "KB\n";
        }

        analysisFile.close();
    }
};

// Generate random packets for simulation
void generatePackets(Router& router) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> sizeDist(1, 500);
    uniform_int_distribution<> ipDist(1, 255);

    for (int i = 0; i < 10; ++i) {
        string srcIP = "192.168.1." + to_string(ipDist(gen));
        string destIP = "10.0.0." + to_string(ipDist(gen));
        int size = sizeDist(gen);
        router.addPacket(Packet(srcIP, destIP, size));
    }
}

// Process packets at a router
void processRouterPackets(Router& router) {
    router.processPackets();
    router.logProcessedPackets();
}

int main() {
    vector<Router> routers = {Router("Router1"), Router("Router2"), Router("Router3")};

    // Step 1: Generate packets
    vector<thread> packetThreads;
    for (auto& router : routers) {
        packetThreads.emplace_back(generatePackets, ref(router));
    }
    for (auto& thread : packetThreads) {
        thread.join();
    }

    // Step 2: Process packets
    vector<thread> processThreads;
    for (auto& router : routers) {
        processThreads.emplace_back(processRouterPackets, ref(router));
    }
    for (auto& thread : processThreads) {
        thread.join();
    }

    // Step 3: Analyze traffic
    TrafficAnalyzer analyzer;
    analyzer.analyzeTraffic(routers);
    analyzer.logTrafficAnalysis();

    cout << "Traffic analysis completed. Check logs for details.\n";
    return 0;
}

#include <iostream>
#include <queue>
#include <vector>
#include <string>
#include <thread>
#include <mutex>
#include <fstream>
#include <map>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

struct Packet {
    string source;
    string destination;
    int size; // Size in KB

    Packet(const string& src, const string& dest, int sz) : source(src), destination(dest), size(sz) {}
};

// Router class
class Router {
private:
    string routerId;
    queue<Packet> packetQueue;
    vector<Packet> processedPackets;
    mutex mtx;

public:
    Router(const string& id) : routerId(id) {}

    void addPacket(const Packet& packet) {
        lock_guard<mutex> lock(mtx);
        packetQueue.push(packet);
    }

    void processPackets() {
        lock_guard<mutex> lock(mtx);
        while (!packetQueue.empty()) {
            Packet packet = packetQueue.front();
            packetQueue.pop();
            processedPackets.push_back(packet);
        }
    }

    void logProcessedPackets() const {
        lock_guard<mutex> lock(mtx);
        ofstream logFile(routerId + "_traffic.log");

        for (const auto& packet : processedPackets) {
            logFile << "Source: " << packet.source << ", Destination: " << packet.destination
                    << ", Size: " << packet.size << "KB\n";
        }
        logFile.close();
    }

    int getTotalTraffic() const {
        lock_guard<mutex> lock(mtx);
        int totalTraffic = 0;
        for (const auto& packet : processedPackets) {
            totalTraffic += packet.size;
        }
        return totalTraffic;
    }

    string getRouterId() const { return routerId; }
};

// Traffic Analyzer
class TrafficAnalyzer {
private:
    map<string, int> routerTrafficData;

public:
    void analyzeTraffic(const vector<Router>& routers) {
        for (const auto& router : routers) {
            routerTrafficData[router.getRouterId()] = router.getTotalTraffic();
        }
    }

    void logTrafficAnalysis() const {
        ofstream analysisFile("traffic_analysis.log");

        analysisFile << "Router Traffic Analysis:\n";
        analysisFile << "-------------------------\n";

        for (const auto& [routerId, totalTraffic] : routerTrafficData) {
            analysisFile << "Router: " << routerId << ", Total Traffic: " << totalTraffic << "KB\n";
        }

        analysisFile.close();
    }
};

// Generate random packets for simulation
void generatePackets(Router& router) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> sizeDist(1, 500);
    uniform_int_distribution<> ipDist(1, 255);

    for (int i = 0; i < 10; ++i) {
        string srcIP = "192.168.1." + to_string(ipDist(gen));
        string destIP = "10.0.0." + to_string(ipDist(gen));
        int size = sizeDist(gen);
        router.addPacket(Packet(srcIP, destIP, size));
    }
}

// Process packets at a router
void processRouterPackets(Router& router) {
    router.processPackets();
    router.logProcessedPackets();
}

int main() {
    vector<Router> routers = {Router("Router1"), Router("Router2"), Router("Router3")};

    // Step 1: Generate packets
    vector<thread> packetThreads;
    for (auto& router : routers) {
        packetThreads.emplace_back(generatePackets, ref(router));
    }
    for (auto& thread : packetThreads) {
        thread.join();
    }

    // Step 2: Process packets
    vector<thread> processThreads;
    for (auto& router : routers) {
        processThreads.emplace_back(processRouterPackets, ref(router));
    }
    for (auto& thread : processThreads) {
        thread.join();
    }

    // Step 3: Analyze traffic
    TrafficAnalyzer analyzer;
    analyzer.analyzeTraffic(routers);
    analyzer.logTrafficAnalysis();

    cout << "Traffic analysis completed. Check logs for details.\n";
    return 0;
}



//cellular network optimization 


#include <iostream>
#include <map>
#include <set>
#include <vector>
#include <queue>
#include <thread>
#include <mutex>
#include <fstream>
#include <string>
#include <climits>

using namespace std;

struct Tower {
    string id;
    int load; // Current data load on the tower

    Tower(string id, int load) : id(id), load(load) {}
};

class Network {
private:
    map<string, set<string>> connections; // Graph: Tower ID -> Set of connected Tower IDs
    map<string, Tower> towers;            // Tower ID -> Tower
    mutex mtx;

public:
    void addTower(const string& id, int load) {
        lock_guard<mutex> lock(mtx);
        towers[id] = Tower(id, load);
    }

    void addConnection(const string& from, const string& to) {
        lock_guard<mutex> lock(mtx);
        connections[from].insert(to);
        connections[to].insert(from); // Assuming bidirectional connection
    }

    vector<string> findShortestPath(const string& start, const string& end) {
        lock_guard<mutex> lock(mtx);

        if (connections.find(start) == connections.end() || connections.find(end) == connections.end()) {
            return {};
        }

        map<string, string> previous; // To reconstruct the path
        map<string, int> distances;   // Shortest distance to each tower
        set<string> visited;
        priority_queue<pair<int, string>, vector<pair<int, string>>, greater<>> pq;

        for (const auto& tower : towers) {
            distances[tower.first] = INT_MAX;
        }
        distances[start] = 0;

        pq.push({0, start});

        while (!pq.empty()) {
            auto [currentDistance, currentTower] = pq.top();
            pq.pop();

            if (visited.find(currentTower) != visited.end()) {
                continue;
            }

            visited.insert(currentTower);

            for (const auto& neighbor : connections[currentTower]) {
                int newDistance = currentDistance + 1; // All edges have equal weight
                if (newDistance < distances[neighbor]) {
                    distances[neighbor] = newDistance;
                    previous[neighbor] = currentTower;
                    pq.push({newDistance, neighbor});
                }
            }
        }

        vector<string> path;
        for (string at = end; at != ""; at = previous[at]) {
            path.push_back(at);
        }
        reverse(path.begin(), path.end());

        return (path.size() > 1 && path.front() == start) ? path : vector<string>{};
    }

    void optimizeTraffic(const string& overloadedTower) {
        lock_guard<mutex> lock(mtx);

        if (towers[overloadedTower].load <= 100) {
            return; // Load is manageable
        }

        cout << "Optimizing traffic for tower: " << overloadedTower << "\n";

        for (const auto& neighbor : connections[overloadedTower]) {
            int transferLoad = (towers[overloadedTower].load - 100) / 2;
            towers[neighbor].load += transferLoad;
            towers[overloadedTower].load -= transferLoad;

            ofstream logFile("network_optimization.log", ios::app);
            logFile << "Transferred " << transferLoad << " load from " << overloadedTower
                    << " to " << neighbor << "\n";
            logFile.close();

            if (towers[overloadedTower].load <= 100) {
                break;
            }
        }
    }

    void simulateTraffic() {
        lock_guard<mutex> lock(mtx);

        for (auto& [id, tower] : towers) {
            tower.load += rand() % 50; // Simulating data load increase
        }
    }

    void logTowerStatus() {
        lock_guard<mutex> lock(mtx);

        ofstream logFile("tower_status.log");
        for (const auto& [id, tower] : towers) {
            logFile << "Tower ID: " << id << ", Load: " << tower.load << "\n";
        }
        logFile.close();
    }
};

// Simulate real-time traffic
void simulateTraffic(Network& network) {
    while (true) {
        network.simulateTraffic();
        this_thread::sleep_for(chrono::seconds(5));
    }
}

// Optimize network
void optimizeNetwork(Network& network) {
    while (true) {
        for (const auto& [id, tower] : network) {
            if (tower.load > 100) {
                network.optimizeTraffic(id);
            }
        }
        this_thread::sleep_for(chrono::seconds(10));
    }
}

int main() {
    Network network;

    // Adding towers
    network.addTower("T1", 50);
    network.addTower("T2", 30);
    network.addTower("T3", 70);
    network.addTower("T4", 40);

    // Adding connections
    network.addConnection("T1", "T2");
    network.addConnection("T2", "T3");
    network.addConnection("T3", "T4");

    // Start traffic simulation and optimization in separate threads
    thread trafficThread(simulateTraffic, ref(network));
    thread optimizationThread(optimizeNetwork, ref(network));

    trafficThread.join();
    optimizationThread.join();

    return 0;
}



//telecom billing system 

#include <iostream>
#include <map>
#include <queue>
#include <vector>
#include <string>
#include <thread>
#include <mutex>
#include <fstream>
#include <random>
#include <chrono>

using namespace std;

// Class to represent a telecom service
class Service {
private:
    string serviceName;
    double costPerUnit;

public:
    Service(const string& name, double cost) : serviceName(name), costPerUnit(cost) {}
    double getCostPerUnit() const { return costPerUnit; }
    string getServiceName() const { return serviceName; }
};

// Class to represent a user
class User {
private:
    string username;
    map<string, int> serviceUsage; // Service name and usage

public:
    User(const string& name) : username(name) {}

    void addServiceUsage(const string& serviceName, int units) {
        serviceUsage[serviceName] += units;
    }

    const map<string, int>& getServiceUsage() const { return serviceUsage; }
    string getUsername() const { return username; }
};

// Class to represent a billing system
class BillingSystem {
private:
    map<string, Service> services;
    map<string, User> users;
    mutex mtx;

public:
    void addService(const string& name, double cost) {
        lock_guard<mutex> lock(mtx);
        services[name] = Service(name, cost);
    }

    void addUser(const string& username) {
        lock_guard<mutex> lock(mtx);
        users[username] = User(username);
    }

    void generateUsageData() {
        lock_guard<mutex> lock(mtx);

        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> dist(1, 100);

        for (auto& [username, user] : users) {
            for (const auto& [serviceName, service] : services) {
                user.addServiceUsage(serviceName, dist(gen)); // Random usage
            }
        }
    }

    void generateBills() {
        lock_guard<mutex> lock(mtx);

        for (const auto& [username, user] : users) {
            double totalBill = 0;
            ofstream billFile(username + "_bill.txt");

            billFile << "Monthly Bill for User: " << username << "\n";
            billFile << "----------------------------------\n";

            for (const auto& [serviceName, usage] : user.getServiceUsage()) {
                double cost = services[serviceName].getCostPerUnit() * usage;
                totalBill += cost;
                billFile << "Service: " << serviceName << ", Usage: " << usage 
                         << ", Cost: $" << cost << "\n";
            }

            billFile << "----------------------------------\n";
            billFile << "Total Bill: $" << totalBill << "\n";
            billFile.close();
        }
    }
};

void simulateUserUsage(BillingSystem& system) {
    system.generateUsageData();
}

void simulateBilling(BillingSystem& system) {
    system.generateBills();
}

int main() {
    BillingSystem billingSystem;

    // Adding services
    billingSystem.addService("Voice Call", 0.1);  // $0.1 per minute
    billingSystem.addService("Data", 0.05);       // $0.05 per MB
    billingSystem.addService("SMS", 0.02);        // $0.02 per SMS

    // Adding users
    billingSystem.addUser("Alice");
    billingSystem.addUser("Bob");
    billingSystem.addUser("Charlie");

    // Simulate usage and billing
    thread usageThread(simulateUserUsage, ref(billingSystem));
    thread billingThread(simulateBilling, ref(billingSystem));

    usageThread.join();
    billingThread.join();

    cout << "Billing completed. Check individual user bill files for details.\n";

    return 0;
}



//spam detection system 

#include <iostream>
#include <unordered_map>
#include <vector>
#include <string>
#include <fstream>
#include <thread>
#include <mutex>
#include <algorithm>

using namespace std;

// Base class Message
class Message {
protected:
    string content;
    bool isSpam;

public:
    Message(const string& msg) : content(msg), isSpam(false) {}
    virtual ~Message() = default;

    virtual string getMessageType() const = 0;

    const string& getContent() const { return content; }
    bool checkSpam() const { return isSpam; }
    void markSpam() { isSpam = true; }
};

// Derived class SMS
class SMS : public Message {
public:
    SMS(const string& msg) : Message(msg) {}
    string getMessageType() const override { return "SMS"; }
};

// Derived class MMS
class MMS : public Message {
public:
    MMS(const string& msg) : Message(msg) {}
    string getMessageType() const override { return "MMS"; }
};

// Thread-safe structure to handle message processing
class SpamDetector {
private:
    unordered_map<string, int> spamKeywords;
    vector<shared_ptr<Message>> messages;
    mutex mtx;

public:
    SpamDetector() {
        // Initialize spam keywords with scores
        spamKeywords = {
            {"win", 10}, {"prize", 8}, {"free", 7}, {"money", 9},
            {"urgent", 6}, {"call", 5}, {"offer", 4}, {"cash", 10}
        };
    }

    void addMessage(shared_ptr<Message> message) {
        lock_guard<mutex> lock(mtx);
        messages.push_back(message);
    }

    void processMessages() {
        vector<shared_ptr<Message>> localMessages;

        {
            lock_guard<mutex> lock(mtx);
            localMessages.swap(messages);
        }

        for (auto& message : localMessages) {
            int spamScore = 0;

            for (const auto& [keyword, score] : spamKeywords) {
                if (message->getContent().find(keyword) != string::npos) {
                    spamScore += score;
                }
            }

            if (spamScore > 15) {
                message->markSpam();
            }
        }
    }

    void logResults(const string& logFilename) {
        ofstream logfile(logFilename, ios::app);

        for (const auto& message : messages) {
            logfile << "Message Type: " << message->getMessageType() << "\n";
            logfile << "Content: " << message->getContent() << "\n";
            logfile << "Status: " << (message->checkSpam() ? "Spam" : "Not Spam") << "\n\n";
        }
    }
};

void processBatch(SpamDetector& detector) {
    detector.processMessages();
    detector.logResults("spam_detection.log");
}

int main() {
    SpamDetector detector;

    // Simulate incoming messages
    detector.addMessage(make_shared<SMS>("You won a free prize! Call now!"));
    detector.addMessage(make_shared<MMS>("This is a test message."));
    detector.addMessage(make_shared<SMS>("Urgent! You have cash waiting for you."));

    // Multithreaded processing
    thread t1(processBatch, ref(detector));
    thread t2(processBatch, ref(detector));

    t1.join();
    t2.join();

    cout << "Spam detection completed. Check spam_detection.log for details.\n";

    return 0;
}





//call routing system 
#include <iostream> #include <thread> #include <queue> #include <unordered_map> #include <mutex> #include <vector> #include <string> #include <fstream> #include <chrono> #include <condition_variable> #include <set>

using namespace std;

class Call { public: string callId; string source; string destination; int priority;

Call(string id, string src, string dest, int prio)
    : callId(id), source(src), destination(dest), priority(prio) {}

bool operator<(const Call& other) const {
    return priority < other.priority;  // Higher priority calls first
}

};

class CallRouter { private: priority_queue<Call> callQueue; unordered_map<string, string> activeCalls; mutex mtx; condition_variable cv; bool running;

public: CallRouter() : running(true) {}

void addCall(const Call& call) {
    lock_guard<mutex> lock(mtx);
    callQueue.push(call);
    cv.notify_one();
}

void processCalls() {
    while (running) {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, [&] { return !callQueue.empty() || !running; });

        if (!running) break;

        Call call = callQueue.top();
        callQueue.pop();
        lock.unlock();

        // Simulate call routing
        {
            lock_guard<mutex> lock(mtx);
            activeCalls[call.callId] = call.destination;
        }

        cout << "Routing call " << call.callId << " from " << call.source
             << " to " << call.destination << " with priority " << call.priority << endl;

        this_thread::sleep_for(chrono::seconds(2)); // Simulating processing time

        // Simulate call end
        {
            lock_guard<mutex> lock(mtx);
            activeCalls.erase(call.callId);
            cout << "Call " << call.callId << " has ended." << endl;
        }
    }
}

void stop() {
    running = false;
    cv.notify_all();
}

void logActiveCalls() {
    lock_guard<mutex> lock(mtx);
    ofstream logFile("active_calls.txt", ios::app);
    logFile << "Active Calls at " << chrono::system_clock::to_time_t(chrono::system_clock::now()) << ":\n";
    for (const auto& call : activeCalls) {
        logFile << "Call ID: " << call.first << " -> Destination: " << call.second << endl;
    }
    logFile.close();
}

};

int main() { CallRouter router;

thread routerThread(&CallRouter::processCalls, &router);

vector<thread> callerThreads;

// Simulating callers adding calls
for (int i = 1; i <= 5; ++i) {
    callerThreads.push_back(thread([&, i]() {
        string callId = "Call" + to_string(i);
        string source = "User" + to_string(i);
        string destination = "User" + to_string(i + 5);
        int priority = rand() % 10 + 1; // Priority between 1 and 10
        router.addCall(Call(callId, source, destination, priority));
    }));
    this_thread::sleep_for(chrono::seconds(1));
}

// Wait for all caller threads to finish
for (auto& t : callerThreads) {
    t.join();
}

// Log active calls periodically
thread loggerThread([&]() {
    for (int i = 0; i < 5; ++i) {
        router.logActiveCalls();
        this_thread::sleep_for(chrono::seconds(3));
    }
});

loggerThread.join();

// Stop the router and join the router thread
router.stop();
routerThread.join();

return 0;

}

